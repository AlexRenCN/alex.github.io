<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/alex.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/alex.github.io/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/alex.github.io/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/alex.github.io/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/alex.github.io/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/alex.github.io/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/alex.github.io/',
    scheme: 'Muse',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="JAVA之路">
<meta name="keywords" content="JAVA,MySQL,Linux">
<meta property="og:type" content="website">
<meta property="og:title" content="Alex">
<meta property="og:url" content="https://alexrencn.github.io/page/2/index.html">
<meta property="og:site_name" content="Alex">
<meta property="og:description" content="JAVA之路">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alex">
<meta name="twitter:description" content="JAVA之路">






  <link rel="canonical" href="https://alexrencn.github.io/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Alex</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/alex.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alex</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">可达鸭眉头一紧，发现编程并不简单</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/alex.github.io/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/alex.github.io/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://alexrencn.github.io/alex.github.io/2018/09/12/2018-09-01-JAVA线程池队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Ren">
      <meta itemprop="description" content="JAVA之路">
      <meta itemprop="image" content="/alex.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/alex.github.io/2018/09/12/2018-09-01-JAVA线程池队列/" itemprop="url">
                  JAVA线程池队列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-12 13:54:21" itemprop="dateCreated datePublished" datetime="2018-09-12T13:54:21+08:00">2018-09-12</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/alex.github.io/2018/09/12/2018-09-01-JAVA线程池队列/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/alex.github.io/2018/09/12/2018-09-01-JAVA线程池队列/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/alex.github.io/2018/09/12/2018-09-01-JAVA线程池队列/" class="leancloud_visitors" data-flag-title="JAVA线程池队列">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>ThreadPoolExecutor构造器中BlockingQueue<runable>的描述</runable></p>
<p>###JDK8中的队列实现</p>
<p>####SynchronousQueue<br><strong>直接提交的队列</strong><br><strong>默认使用：</strong> newCachedThreadPool</p>
<blockquote>
<p>该队列没有容量，只有一个元素存在，每一个插入操作都要等待对应的删除操作，每一个删除操作也需要等待对于的插入操作<br>需要注意最大线程数的设置，避免操作被拒绝,是一个公平队列，先进先出</p>
</blockquote>
<p>####ArrayBlockingQueue<br><strong>有界堵塞队列</strong></p>
<blockquote>
<p>使用数组实现，任务队列放满之后才会将线程池从corePoolSize进行提升，注重保持在核心数量,是一个公平队列，先进先出</p>
</blockquote>
<p>####LinkedBlockingQueue<br><strong>有界堵塞队列</strong><br><strong>默认使用：</strong> newFixedThreadPool、newSingleThreadExecutor</p>
<blockquote>
<p>使用链表实现，默认大小是Integer.MAX_VALUE，所以最好手动指定大小，每个提交的任务都会储存在一个node对象中，实现了锁分离，添加和移除任务各有一把锁，是一个公平队列，先进先出</p>
</blockquote>
<p>####DelayedWorkQueue<br><strong>无界堵塞队列</strong><br><strong>默认使用：</strong> ScheduledThreadPoolExecutor、newSingleThreadScheduledExecutor</p>
<blockquote>
<p>可以按照任务优先级执行，采用消费者-生产者模式进行消费</p>
</blockquote>
<p>####PriorityBlockingQueue<br><strong>优先任务队列</strong></p>
<blockquote>
<p>是一种特殊的无界队列，可以按照任务优先级执行，元素可以实现Comparable接口，不允许为null</p>
</blockquote>
<p>####DelayQueue<br><strong>无界堵塞队列</strong></p>
<blockquote>
<p>每个元素都会有一定的延时，然后释放</p>
</blockquote>
<p>####LinkedBlockingDueue<br><strong>有界堵塞队列</strong></p>
<blockquote>
<p>使用链表实现，允许从双端进行插入和删除，默认大小是Integer.MAX_VALUE，所以最好手动指定大小，每个提交的任务都会储存在一个node对象中，实现了锁分离，添加和移除任务各有一把锁，任务队列放满之后才会将线程池从corePoolSize进行提升，注重保持在核心数量,是一个公平队列，先进先出</p>
</blockquote>
<p>####LinkedTransferQueue<br><strong>无界堵塞队列</strong></p>
<blockquote>
<p>使用链表实现，采用消费者-生产者模式进行消费，是一个公平队列，先进先出</p>
</blockquote>
<p>###线程池不同队列如何运行</p>
<p>####有界队列工作步骤</p>
<ol>
<li>如果实际线程数小于corePoolSize，则优先创建新的线程</li>
<li>若大于corePoolSize，加入等待队列<br>####无界队列工作步骤</li>
<li>如果实际线程数小于corePoolSize，则优先创建新的线程</li>
<li>若大于corePoolSize，加入等待队列</li>
<li>若等待队列已满，无法加入，并且总线程数不超过maxSize则创建新的进程执行任务</li>
<li>若大于maxSize则执行拒绝策略<br>####直接提交队列工作步骤</li>
<li>提交给线程执行</li>
<li>如果没有空闲线程，则会创建新的线程</li>
<li>如果已经达到maxSize最大值则执行拒绝策略</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://alexrencn.github.io/alex.github.io/2018/09/12/2018-08-18-JVM内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Ren">
      <meta itemprop="description" content="JAVA之路">
      <meta itemprop="image" content="/alex.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/alex.github.io/2018/09/12/2018-08-18-JVM内存模型/" itemprop="url">
                  JVM内存模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-12 13:54:21" itemprop="dateCreated datePublished" datetime="2018-09-12T13:54:21+08:00">2018-09-12</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/alex.github.io/2018/09/12/2018-08-18-JVM内存模型/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/alex.github.io/2018/09/12/2018-08-18-JVM内存模型/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/alex.github.io/2018/09/12/2018-08-18-JVM内存模型/" class="leancloud_visitors" data-flag-title="JVM内存模型">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<blockquote>
<p>JAVA通过JVM实现跨平台，在不同平台上允许不同的虚拟机执行同样的字节码文件，来实现跨平台，这是java编译后的代码和机器指令交互的地方，理解JVM有助于在日常工作中避免JVM可能出现的压力及异常，并且可以在项目出现瓶颈时定位问题并解决</p>
</blockquote>
<h2 id="JVM区域划分"><a href="#JVM区域划分" class="headerlink" title="JVM区域划分"></a>JVM区域划分</h2><ol>
<li>JVM指令系统<blockquote>
<p>用来指定需要在目标平台上的操作指令</p>
<ol>
<li><strong>操作码</strong> 用来执行一条操作的性质</li>
<li><strong>操作数</strong> 紧随操作码之后，被分为两个以上字节</li>
</ol>
</blockquote>
</li>
<li>JVM寄存器<blockquote>
<p>用来保存CPU中包含的保存系统状态和处理信息的寄存器组，减少虚拟机对堆栈的访问，常用的JVM寄存器有四种</p>
<ol>
<li>PC程序计数器，用于记录程序的执行</li>
<li>optop操作数栈顶指针，用于记录JAVA栈的指针</li>
<li>frame当前执行环境指针，用于记录JAVA栈的指针</li>
<li>vars当前执行环境第一个局部变量指针，用于记录JAVA栈的指针</li>
</ol>
</blockquote>
</li>
<li>JVM栈结构<ol>
<li><strong>局部变量</strong> 存储类方法中的局部变量</li>
<li><strong>执行环境</strong> 上次调用的方法、局部变量指针、操作数栈、栈底指针</li>
<li><strong>操作数栈</strong> 存储运算所需要的操作数和结果</li>
</ol>
</li>
<li>JVM碎片回收堆</li>
<li><p>JVM存储区</p>
<ol>
<li><strong>常量缓冲池</strong> 类名、方法名、常量</li>
<li><strong>方法区</strong> 方法字节码<h2 id="JAVA运行时的内存结构"><a href="#JAVA运行时的内存结构" class="headerlink" title="JAVA运行时的内存结构"></a>JAVA运行时的内存结构</h2><blockquote>
<p>局部变量表是在编译阶段已经确定的内容，包含已知的基本数据类型，对象引用（指向对象的原始地址或者引用指针、对象句柄、或者用来指向一条字节码指令的returnAddress类型），该区域在方法执行期间不会做出改变大小</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>方法区</strong> 被所有线程共享，存储加载类时读取的类信息，常量，静态变量以及字节码</p>
</li>
<li><strong>JAVA虚拟机栈</strong> 每一个线程都会独享一个栈，为虚拟机执行方法进行服务，存储局部变量表、操作数栈、动态链接、方法出口等</li>
<li><strong>JAVA虚拟机堆</strong> 被所有线程共享，在虚拟机启动时创建，用于存放对象实例，可以细分为新生代Young和老年代Old，年轻代可以再次划分为Eden、FromSurvivor和ToSurvivor，默认情况下新生代占堆内存的三分之一，随着JIT编译器和逃逸分析的发展，虚拟机可以更好的进行栈上分配和标量替换，所以并不是所有的对象创建都会分配到Heap了</li>
<li><strong>本地方法栈</strong> 每一个线程都会独享一个栈，为虚拟机执行Native方法进行服务，存储局部变量表、操作数栈、动态链接、方法出口等</li>
<li><strong>程序计数器</strong> 每一个线程都会独享一个程序计数器，相互之间不会影响，记录当前字节码的行号指令器</li>
</ol>
<h2 id="JVM执行程序的过程"><a href="#JVM执行程序的过程" class="headerlink" title="JVM执行程序的过程"></a>JVM执行程序的过程</h2><ol>
<li>加载Class文件</li>
<li>管理、分配内存</li>
<li>进行垃圾回收</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://alexrencn.github.io/alex.github.io/2018/09/12/2018-08-22-支付系统设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Ren">
      <meta itemprop="description" content="JAVA之路">
      <meta itemprop="image" content="/alex.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/alex.github.io/2018/09/12/2018-08-22-支付系统设计/" itemprop="url">
                  支付系统的设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-12 13:54:21" itemprop="dateCreated datePublished" datetime="2018-09-12T13:54:21+08:00">2018-09-12</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/alex.github.io/2018/09/12/2018-08-22-支付系统设计/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/alex.github.io/2018/09/12/2018-08-22-支付系统设计/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/alex.github.io/2018/09/12/2018-08-22-支付系统设计/" class="leancloud_visitors" data-flag-title="支付系统的设计">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<blockquote>
<p>虽然之前的从业的公司一直和金融息息相关，也与多家支付或者银行系统进行过系统对接，但是支付系统一直没能从整体应用中真正独立</p>
</blockquote>
<p>####业务场景描述</p>
<p>#####混沌初开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">[业务流程1]--&gt;[业务1]</span><br><span class="line">[业务流程2]--&gt;[业务2]</span><br><span class="line">[业务流程3]--&gt;[业务3]</span><br><span class="line">[业务1]--&gt;[支付]</span><br><span class="line">[业务2]--&gt;[支付]</span><br><span class="line">[业务3]--&gt;[支付]</span><br></pre></td></tr></table></figure></p>
<p>在这个阶段，一般公司只会确认一家公司作为自己的第三方支付，而此时公司的技术人员架构还并不完整，很难找得到完全熟悉支付业务和支付系统的开发人员，在我接触过的第三方对接的系统里，大部分的基础类来自于支付公司的样例，这部分代码不能保障效率但是可以大大解决开发进度的问题，针对这部分代码也很难有人会维护</p>
<p>#####业务冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">[业务流程1]--&gt;[业务1]</span><br><span class="line">[业务流程2]--&gt;[业务2]</span><br><span class="line">[业务流程3]--&gt;[业务3]</span><br><span class="line">[业务1]--&gt;[支付1]</span><br><span class="line">[业务2]--&gt;[支付1]</span><br><span class="line">[业务3]--&gt;[支付2]</span><br></pre></td></tr></table></figure></p>
<p>经过一定时间的发展，因为支付公司提供的某个接口可用性不高，或者某种业务需求无法满足，可能会新引进一家支付公司，这个时候回针对部分业务进行替换</p>
<p>#####逐渐独立<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">[业务流程1]--&gt;[业务1]</span><br><span class="line">[业务流程2]--&gt;[业务2]</span><br><span class="line">[业务流程3]--&gt;[业务3]</span><br><span class="line">[业务1]--&gt;[支付代理]</span><br><span class="line">[业务2]--&gt;[支付代理]</span><br><span class="line">[业务3]--&gt;[支付代理]</span><br><span class="line">[支付代理]--&gt;[支付1]</span><br><span class="line">[支付代理]--&gt;[支付2]</span><br><span class="line">[支付代理]--&gt;[支付3]</span><br></pre></td></tr></table></figure></p>
<p>随着第三方支付的增加和业务规则的不断变化，需要将业务模型进程抽象剥离，将交易过程进行委托代理，由代理进行实际的链接，简单介绍下这个调用链的各部分组成<br></p>
<ul>
<li>业务：业务模块只需要关心自己要执行的交易类型，以及业务所需要的支付方式<ul>
<li>该部分属于一个统称，业务选择支付方式的部分也可以进行封装，避免耦合</li>
</ul>
</li>
<li>支付代理：作为业务模块和支付模块的HTTP代理负责处理多对多模型下的网关路由，提供规范统一的API接口<ul>
<li>在提供统一API的时候，使用建造者模式是一个不错的选择</li>
<li>不要试图通过任何方式来确定具体参数的合法性，只需要通过合适的机制比如token来确定请求的合法性即可</li>
<li>尽量简化该步骤以增加吞吐量，并且把一切控制权交由支付系统处理</li>
<li>作为一个网络代理，可以添加客户端负载均衡、熔断等策略来避免网络因素导致的资源不释放</li>
</ul>
</li>
<li>支付：作为第三方支付系统的真实对接系统，使用适配器模式将来自支付代理的统一API入参进行转换并进行实际处理，并将结果通过支付代理再次返回给业务系统，需要保证该服务的自治理，避免数据状态不同步造成的事故<ul>
<li>秘钥：基本采用第三方支付提供的非对称性加密方案</li>
<li>渠道：这里的渠道代表着第三方支付对本公司系统的渠道标识</li>
<li>接口：提供具体的业务模块，比如红包，退款</li>
<li>同步通知：在双方的系统内进行一次HTTP链接，实时通知结果</li>
<li>异步通知：在某些接口上需要跳转到第三方页面进行密码输入等操作，此时用户行为发生在浏览器中，第三方支付会使用异步通知的方式发送到一个指定的接口中</li>
<li>其他通知：如果该交易发生在线下，第三方支付会将结果发送到协商的接口中，通知本公司系统该交易的发生</li>
<li>幂等性：针对同一笔交易有且仅有一个结果，</li>
<li>自治理：自治理分为两部分，一部分是对第三方支付，需要保证长时间未明确结果的交易和第三方支付状态同步，另一部分是对业务系统，在返回结果时未收到响应应该及时切断链接避免木桶效应，并使用延时队列等方式再次发送结果，避免上游系统崩溃导致的系统性能占用</li>
</ul>
</li>
</ul>
<p>######API变化问题</p>
<blockquote>
<p>第三方支付系统的API升级不可控，在生产环境中进行版本升级需要在编码中添加参数并进行灰度发布，为了保证7*24小时服务，不可能频繁进行发布，此时应该动态获取参数</p>
</blockquote>
<p>业务支付配置表</p>
<ul>
<li>规则ID</li>
<li>业务ID</li>
<li>支付系统ID</li>
</ul>
<p>第三方支付配置表 </p>
<ul>
<li>支付系统ID</li>
<li>请求方式</li>
<li>秘钥规则ID</li>
</ul>
<p>第三方支付秘钥表</p>
<ul>
<li>秘钥规则ID</li>
<li>加密方式</li>
<li>公钥</li>
<li>私钥</li>
</ul>
<p>第三方支付参数表</p>
<ul>
<li>参数表ID</li>
<li>支付系统ID</li>
<li>功能接口ID</li>
<li>商户号</li>
<li>版本号</li>
<li>同步地址</li>
<li>异步地址</li>
</ul>
<p>第三方支付个性化参数表</p>
<ul>
<li>参数表ID</li>
<li>参数名</li>
<li>默认值</li>
</ul>
<p>把具体对接时的参数以表的形式存储，提供合适的缓存机制，保证效率，以及更新的速度</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://alexrencn.github.io/alex.github.io/2018/09/12/2018-08-18-JAVA的对象锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Ren">
      <meta itemprop="description" content="JAVA之路">
      <meta itemprop="image" content="/alex.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/alex.github.io/2018/09/12/2018-08-18-JAVA的对象锁/" itemprop="url">
                  JAVA的对象锁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-12 13:54:21" itemprop="dateCreated datePublished" datetime="2018-09-12T13:54:21+08:00">2018-09-12</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/alex.github.io/2018/09/12/2018-08-18-JAVA的对象锁/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/alex.github.io/2018/09/12/2018-08-18-JAVA的对象锁/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/alex.github.io/2018/09/12/2018-08-18-JAVA的对象锁/" class="leancloud_visitors" data-flag-title="JAVA的对象锁">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="JAVA线程调度模式"><a href="#JAVA线程调度模式" class="headerlink" title="JAVA线程调度模式"></a>JAVA线程调度模式</h2><blockquote>
<p>在谈及JAVA锁之前，不如先去了解一下JAVA线程的调度模式吧，线程调度模式一般分为两种，抢占式调度和协同式调度，<strong>抢占式调度</strong>是由系统在某种算法的运行下给所有线程CPU的时间切片，这个时候所有的线程都会在分配到的时间内进行自己的操作，但是优先级低的线程可能就没有得到分配，所谓并行也只不过是轮流占用CPU资源，并没有达到在单核中同时执行多个线程，<strong>协同式调度</strong>是由线程完成后主动将CPU让给下一个线程，而JAVA使用的是抢占式调度，根据线程优先级来分配CPU时间片</p>
</blockquote>
<h2 id="JAVA的对象头"><a href="#JAVA的对象头" class="headerlink" title="JAVA的对象头"></a>JAVA的对象头</h2><blockquote>
<p>在这里简单介绍下JAVA对象锁实现的机制，其实现是依靠JAVA对象头，JAVA对象头中存放着对象的哈希值、锁信息、对象的年龄以及对象的元数据等信息，对象头的长度为2字来存储</p>
</blockquote>
<table><br>    <thead><br>        <tr><br>            <th>锁状态</th><br>            <th>存放内容</th><br>            <th>锁标志位(2bit)</th><br>        </tr><br>    </thead><br>    <body><br>        <tr><br>            <th>无锁</th><br>            <th>对象的HashCode(25bit)+分代年龄(4bit)+是否是偏向锁(1bit)</th><br>            <th>01</th><br>        </tr><br>        <tr><br>            <th>偏向锁</th><br>            <th>线程ID(23bit)+时间标记Epoch(2bit)+分代年龄(4bit)+是否是偏向锁(1bit)</th><br>            <th>01</th><br>        </tr><br>        <tr><br>            <th>轻量锁</th><br>            <th>栈中锁记录指针(30bit)</th><br>            <th>00</th><br>        </tr><br>        <tr><br>            <th>重量锁</th><br>            <th>珍重互斥量的指针(30bit)</th><br>            <th>10</th><br>        </tr><br>        <tr><br>            <th>GC标记</th><br>            <th>空(30bit)</th><br>            <th>11</th><br>        </tr><br>    </body><br></table>

<h2 id="JAVA的锁"><a href="#JAVA的锁" class="headerlink" title="JAVA的锁"></a>JAVA的锁</h2><blockquote>
<p>每一个JAVA对象都可以作为锁，JAVA对象锁等级分为4种，由低到高分别是无锁、偏向锁、轻量锁、重量锁</p>
</blockquote>
<p>##偏向锁<br>拥有同步锁的对象在同步时只需要检查偏向线程ID和当前线程ID是否一致<br><br><strong>场景</strong>总是由同一个线程来持有这个对象锁，很少发生竞争<br><br><strong>加锁</strong>发生在第一次进入同步代码块的时候，会使用CAS操作记录下当前线程的ID，并改变锁标志位<br><br><strong>升级</strong>如果发现当前线程和偏向线程不一致，则发生了锁竞争，需要膨胀为轻量级锁<br><br><strong>解锁</strong>发生在第一次出现锁竞争的时候，线程会等待全局安全点的到来，暂停偏向线程，查看该线程目前是否已经退出了同步块来决定是释放还是升级，然后唤醒偏向线程<br></p>
<p>##轻量锁<br>轻量锁在每次进入和退出同步代码块的时候都需要使用CAS操作来更新对象头，每次都需要加锁和释放锁<br><br><strong>场景</strong>由少量线程进行资源的争夺<br><br><strong>加锁</strong>在MarkWord里记录当前线程的指针，使用CAS操作修改锁标示为到00<br><br><strong>升级</strong>线程在多次尝试占用轻量级锁失败之后，膨胀为重量级锁，将锁释放并且等待线程唤醒，修改所标记为10，并唤醒线程，重新争夺锁<br><br><strong>解锁</strong>使用CAS操作将锁为置为无锁<br></p>
<p>##重量锁</p>
<p>重量级锁每次进入和退出同步代码块的时候都需要进行竞争，竞争不到的线程进入堵塞并等待唤醒<br><br><strong>场景</strong>进行锁争夺的线程非常多<br><br><strong>加锁</strong>为当前线程分配锁定记录，将对象头指向该记录<br><br><strong>解锁</strong>操作对象头到无锁，唤醒等待该锁的所有线程<br></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://alexrencn.github.io/alex.github.io/2018/09/12/2018-08-17-数据库事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Ren">
      <meta itemprop="description" content="JAVA之路">
      <meta itemprop="image" content="/alex.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/alex.github.io/2018/09/12/2018-08-17-数据库事务/" itemprop="url">
                  数据库事务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-12 13:54:21" itemprop="dateCreated datePublished" datetime="2018-09-12T13:54:21+08:00">2018-09-12</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/alex.github.io/2018/09/12/2018-08-17-数据库事务/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/alex.github.io/2018/09/12/2018-08-17-数据库事务/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/alex.github.io/2018/09/12/2018-08-17-数据库事务/" class="leancloud_visitors" data-flag-title="数据库事务">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>事务是指一组原子性的SQL操作,在数据库中，事务作为一个最小的工作单元存在</p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>一个事务必须遵循ACID原则</p>
<ol>
<li><strong><em>原子性(atomicity)</em></strong> 事务作为最小的一个工作单元，每个事务中包含的所有操作，要么全部成功，要么全部失败</li>
<li><strong><em>一致性(consistency)</em></strong> 数据库总是会从一个一致性状态到另一个一致性状态，事务在操作过程中如果中断，做出的部分修改不会被保存</li>
<li><strong><em>隔离性(isolation)</em></strong> 事务A做出部分修改之后，事务B一般不会看到A所做出的改变（在未提交读隔离级别产生的脏读以及可串行化之下的隔离级别产生的幻读场景下仍然可以看到）</li>
<li><strong><em>持久性(durability)</em></strong> 一旦事务提交，事务提交的数据就会被记录在数据库中持久存储<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2></li>
<li><strong><em>未提交读(READ UNCOMMITED)</em></strong> 事务中的修改即使没有提交，对其他事务也是可见的</li>
<li><strong><em>已提交读(READ COMMITED)</em></strong> 一个事务从开始到提交，所做的任何操作对其他事务都不可见，但是执行两次同样的查询得到的结果可能不同，是大部分数据库的默认隔离级别</li>
<li><strong><em>可重复读(REPEATABLE READ)</em></strong> 一个事务从开始到提交，所做的任何操作对其他事物都不可见，执行多次同样的查询语句得到的结果一致，这是MySQL数据库的默认隔离级别</li>
<li><strong><em>可串行化(SERIALIZABLE)</em></strong> 强制事务串行执行，在读取的每一条数据上都加锁</li>
</ol>
<h2 id="读取问题"><a href="#读取问题" class="headerlink" title="读取问题"></a>读取问题</h2><ol>
<li>脏读 事务可以读取未提交的数据</li>
<li>幻读 当事务在读取某个范围内的记录是，另外一个事务又在该范围内插入了新的记录，之前的事务再次读取该范围内的记录是会产生换行</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个或多个事务在一对资源上相互占用，并且请求占用对方的资源，从而导致恶性循环<br><br>InnoDB会在锁超过等待超时的设定后自动回滚持有行级排它锁最少的事务</p>
<h2 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h2><ul>
<li><p>MySQL采用AUTOCOMMIT自动提交模式，每一个语句都会被当做一个事务进行操作提交，可以手动设置不自动提交</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> AUTOCOMMIT=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并且可以手动进行设定隔离级别</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> SEESION <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> <span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于事务的处理是由MySQL的第三层，也就是存储引擎实现的，所以跨引擎的事务是不可靠的</p>
</li>
<li>InnoDB引擎的锁采用二阶段锁定协议，在事务执行的过程中随时都可以执行加锁，在COMMIT或者ROLLBACK时同时释放所有锁</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://alexrencn.github.io/alex.github.io/2018/09/12/2018-08-27-1.8HashMap链表转红黑树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Ren">
      <meta itemprop="description" content="JAVA之路">
      <meta itemprop="image" content="/alex.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/alex.github.io/2018/09/12/2018-08-27-1.8HashMap链表转红黑树/" itemprop="url">
                  1.8HashMap链表转红黑树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-12 13:54:21" itemprop="dateCreated datePublished" datetime="2018-09-12T13:54:21+08:00">2018-09-12</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/alex.github.io/2018/09/12/2018-08-27-1.8HashMap链表转红黑树/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/alex.github.io/2018/09/12/2018-08-27-1.8HashMap链表转红黑树/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/alex.github.io/2018/09/12/2018-08-27-1.8HashMap链表转红黑树/" class="leancloud_visitors" data-flag-title="1.8HashMap链表转红黑树">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>ConcurrentHashMap的底层数据为数组加链表，哈希冲突的值会放在链表中，如果哈希冲突严重，对ConcurrentHashMap的操作会变为对长链表的操作，为了解决效率问题，1.8会进行红黑树的转换</p>
<p>####红黑树</p>
<p>######什么是红黑树<br>红黑树是一种特殊的平衡二叉树，存放有序的数据，检索的时间复杂度为O(lgn)<br><br>红黑树的特性</p>
<ol>
<li>红黑树的节点非红即黑</li>
<li>根节点为黑色</li>
<li>叶子节点为黑色叶子节点为NIL节点即空节点</li>
<li>如果一个节点为红色，那么他的子节点一定是黑色</li>
<li>从一个节点到该节点的子孙节点的所有路径包含相同个数个黑色节点<br>######红黑树的结构修改</li>
<li>左旋<ul>
<li>将节点A的子右节点调整为自己的父节点，将该子右节点下的子左节点调整为自己的子右节点</li>
</ul>
</li>
<li>右旋<ul>
<li>将节点A的子左节点调整为自己的父节点，将该子左节点下的子右节点调整为自己的子左节点</li>
</ul>
</li>
<li>着色</li>
</ol>
<p>####在什么情况下进行转换<br>java针对链表进行监控，给链表的最大长度设定默认阈值为8，超过阈值就会进行结构改变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2, and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>具体时间是在put方法调用的真实方法putVal中，处理完数据的放置后进行检查<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先对节点进行处理，先判断是否需要进行链表的扩容，以64长度为界限，64以下扩容2倍，64以上将Node转换为TreeNode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at given index unless table is</span></span><br><span class="line"><span class="comment"> * too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://alexrencn.github.io/alex.github.io/2018/09/12/2018-08-23-数据库表连接/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Ren">
      <meta itemprop="description" content="JAVA之路">
      <meta itemprop="image" content="/alex.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/alex.github.io/2018/09/12/2018-08-23-数据库表连接/" itemprop="url">
                  数据库架构优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-12 13:54:21" itemprop="dateCreated datePublished" datetime="2018-09-12T13:54:21+08:00">2018-09-12</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/alex.github.io/2018/09/12/2018-08-23-数据库表连接/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/alex.github.io/2018/09/12/2018-08-23-数据库表连接/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/alex.github.io/2018/09/12/2018-08-23-数据库表连接/" class="leancloud_visitors" data-flag-title="数据库架构优化">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<blockquote>
<p>随着项目的发展，访问量和数据量的增大，项目访问数据库的压力会越来越大，如何针对数据库进行优化，满足日益增长的业务呢</p>
</blockquote>
<p>####读写分离<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">应用[应用]--&gt;|读写|主地址[主地址]</span><br><span class="line">应用[应用]--&gt;|读写|读写分离[读写分离]</span><br><span class="line">应用[应用]--&gt;|读|只读1[只读1]</span><br><span class="line">应用[应用]--&gt;|读|只读2[只读2]</span><br><span class="line">主地址[主地址]--&gt;|读写|主实例[主实例]</span><br><span class="line">读写分离[读写分离]--&gt;|写|主实例[主实例]</span><br><span class="line">读写分离[读写分离]--&gt;|读|只读实例1[只读实例1]</span><br><span class="line">读写分离[读写分离]--&gt;|读|只读实例2[只读实例2]</span><br><span class="line">只读1[只读1]--&gt;|读|只读实例1[只读实例1]</span><br><span class="line">只读2[只读2]--&gt;|读|只读实例2[只读实例2]</span><br></pre></td></tr></table></figure></p>
<p>上图为阿里云数据库的简单设计描述，针对的场景是<strong>读多写少</strong>，把读操作和写操作分开,<br>在一致性要求非常高的情况下，主实例也应该承担一部分读取操作<br><br>实现读写分离的方式：</p>
<ul>
<li>使用编码方式，在程序中定义两个数据源并针对不同的数据访问层使用不同的数据源</li>
<li>使用中间件，在数据访问层和数据库中间添加一个数据库代理服务</li>
</ul>
<p>####分库分别</p>
<p>#####分表<br>随着数据库中的数据增多，对于单表可能出现查询瓶颈，这个时候首先要对数据库表进行分表处理</p>
<ul>
<li><strong>垂直拆分</strong>，按照业务模块进行拆分，将原表中的所有字段进行业务划分，分开出存在不同的表、数据库、或者服务器中</li>
<li><strong>水平拆分</strong>，按照某种规则对单表进行水平切分，进行表分区或者建立多个表，根据规则选择访问</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://alexrencn.github.io/alex.github.io/2018/09/12/2018-08-18-缓存一致性问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Ren">
      <meta itemprop="description" content="JAVA之路">
      <meta itemprop="image" content="/alex.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/alex.github.io/2018/09/12/2018-08-18-缓存一致性问题/" itemprop="url">
                  缓存一致性问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-12 13:54:21" itemprop="dateCreated datePublished" datetime="2018-09-12T13:54:21+08:00">2018-09-12</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/alex.github.io/2018/09/12/2018-08-18-缓存一致性问题/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/alex.github.io/2018/09/12/2018-08-18-缓存一致性问题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/alex.github.io/2018/09/12/2018-08-18-缓存一致性问题/" class="leancloud_visitors" data-flag-title="缓存一致性问题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<blockquote>
<p>在缓存的日常运用中，经常会遇到从缓存中获取某个值，经过业务处理后需要更新数据库对于的数据和该缓存值的内容，而这两个操作和该请求中其他的操作都可能出现异常，甚至时候需要进行IO操作的时间过长，都可能会造成更新缓存和更新数据库只成功一种的情况，这会造成数据不一致，在生产环境中排查这类问题非常困难，如何在设计阶段保证缓存一致性是开发人员在使用缓存时必须考虑的问题</p>
</blockquote>
<p>##读操作的数据一致性</p>
<p>如果缓存命中并直接返回，就不会进行DB操作，也就不存在一致性问题了<br><br>我们主要说一下未命中的情况，读操作涉及到数据库缓存的存放，整个请求的流程应该是</p>
<ol>
<li>从缓存中获取值</li>
<li>缓存命中则使用缓存的值，未命中则需要进行下一步操作</li>
<li>从数据库中获取值，一般是从读数据库中获取</li>
<li>将数据进行缓存</li>
<li>完成请求其他的操作</li>
</ol>
<p>##写操作的数据一致性<br>在写操作中，我们对于缓存的操作并不是修改而是直接淘汰，下一次请求Cache Miss之后去进行缓存的写操作，</p>
<ol>
<li>从缓存中获取值</li>
<li>删除缓存，下一次查询缓存的时候会未命中，而去查询数据库</li>
<li>更新数据库</li>
<li>删除缓存</li>
<li>完成请求其他的操作<blockquote>
<p>如果使用这个策略，我们要注意的地方有，删除缓存后会不会造成缓存击穿的问题，也需要考虑，数据库更新需要耗费时间，在完成更新之前可能有另外的线程以及完成了旧数据的缓存，所以进行了两次缓存淘汰</p>
</blockquote>
</li>
</ol>
<p>##读写分离的数据一致性<br>数据不一致的来源首先来自于主从库不一致，然后由Catch miss时查询从库，导致的缓存和数据库不一致</p>
<ol>
<li><strong>读主库</strong>，针对热点数据，在短时间内可能会发生大量变化，此时主从同步的时间差很容易影响到缓存读取到的数据准确性，针对特殊的数据可以直接从主库读取，避免主从数据库不同步造成的后续影响</li>
<li><strong>数据库监听</strong>，监听从库更新的数据，并针对缓存范围内的内容尝试进行缓存淘汰<br>##其他策略的简述</li>
</ol>
<ul>
<li><strong>不去关心缓存的一致性</strong> 如果是像微博或者头条一样的产品，他们的推送内容是否要求必须一致呢，答案并不是，短时间的缓存不一致并不会造成问题，那么缓存和数据库只要做到最终一致性即可</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://alexrencn.github.io/alex.github.io/2018/09/12/2018-08-20-微服务架构设计及解答/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Ren">
      <meta itemprop="description" content="JAVA之路">
      <meta itemprop="image" content="/alex.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/alex.github.io/2018/09/12/2018-08-20-微服务架构设计及解答/" itemprop="url">
                  微服务架构设计及解答
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-12 13:54:21" itemprop="dateCreated datePublished" datetime="2018-09-12T13:54:21+08:00">2018-09-12</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/alex.github.io/2018/09/12/2018-08-20-微服务架构设计及解答/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/alex.github.io/2018/09/12/2018-08-20-微服务架构设计及解答/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/alex.github.io/2018/09/12/2018-08-20-微服务架构设计及解答/" class="leancloud_visitors" data-flag-title="微服务架构设计及解答">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>##转发说明<br>本文转发自开源中国的<a href="https://www.oschina.net/question/2720166_2283418" target="_blank" rel="noopener">一次高手问答</a>,解答来自于<a href="https://my.oschina.net/u/2335629" target="_blank" rel="noopener">@cloudskyme  张锋</a>,在此文里看到了许多没有注意到的技术栈，以及设计过程中的思考过程，在这里整理了部分解答用作备用，在此表示感谢</p>
<p>#####Q:你好，想请教一下，关于微服务架构service mesh，它比起传统的微服务架构有那些优势的地方?<br>Service mesh被用来处理服务间通讯的专用基础设施层，通过复杂的拓扑结构让请求传递的过程变得更可靠。<br>Service mesh通常作为一组轻量级高性能网络代理，这些代理和程序代码部署在一起，但是应用程序不需要对代理有任何动作。<br>Service mesh是一个网络模型，它是位于TCP/IP之上的抽象层。它假定底层的L3/L4网络是真实存在的，并且能够点对点地传递字节。<br>但与TCP不同的是，Service mesh具有更高的性能。<br>Service mesh最终并不是引入一项新功能，而是功能定位的转变。Web应用程序总是必须管理服务间通信的复杂性。<br>你可以思考下2000年的中型web应用程序的典型架构: 三层应用程序。 在这个模型中，应用程序逻辑、web服务逻辑和存储逻辑都是单独的一层。 层之间的通信虽然复杂，但这种复杂性是限定在一定范围内，因为毕竟只有两个跳转。这里没有“网格”，但是在每个层的代码中处理的跳转之间有通信逻辑。<br>当这种架构方式在面对应用程序内部逻辑越来越复杂化的情形时，它就开始崩溃了。 像Google、Netflix和Twitter这样的公司无时无刻都面临着巨大的流量需求，它们实现了云原生方案的前身: 应用层被分解成许多服务(有时称为“微服务”)，层级间则形成了一个拓扑结构。 在这些系统中，广义的通讯层突然变得相关起来， 但通常以“胖客户端”的库集（library）形式出现， 比如twitter的Finagle，Netflix的Hystrix，以及Google的Stubby就是这样的例子。<br>从很多方面上来讲，像Finagle, Stubby和Hystrix这些库集其实是Service mesh的雏形。虽然它们受其周围环境的细节影响，并且需要使用特定的语言和框架，但是它们是用于管理服务到服务间通信的专用基础设施，并且(在开源Finagle和 Hystrix库集的情形下)可以在其公司之外使用。<br>到了云原生应用时期， 云原生模型本身结合了许多小型服务的微服务方法和两个额外的因素:容器(例如Docker)，它提供了资源隔离和依赖关系管理，以及一个编排层(例如Kubernetes)，它将底层硬件抽象出了一个同质池。<br>这三个组件支持应用程序在负载下可弹性伸缩的自然机制， 并能够处理云平台环境中存在的部分故障。<br>但面对数百个服务或数千个实例，和随时在重新安排实例的编排层，单个请求经由服务拓扑的路径可能非常复杂， 而由于容器使每个服务用不同的语言写入处理变得更容易了，库集方法也就不再可行了。<br>这种复杂性和关键性的结合，激发了对服务到服务间通信的专用基础层的需求，这个专用层与应用程序代码分离出来，并能够捕捉底层环境的高度动态特性。就是这一专用层我们称之为Service mesh。</p>
<p>#####Q:您好，诚然，微服务给我们带来了诸多好处，但是微服务应用是分布式系统，由此必然会带来固有的复杂性，与单体应用比微服务技术显得更复杂一些。测试一个基于微服务架构的应用也是很复杂的任务。采用Spring Boot架构，对一个单体式web应用，测试它的REST API，是很容易的事情。反过来，同样的服务测试需要启动和它有关的所有服务（至少需要这些服务的stubs）。所以不能低估了采用微服务架构带来的复杂性。有什么好的有效的方式减少这些复杂性呢？另外，使用docker和k8s等容器技术是不是微服务架构体系的标配？一个成熟稳定的微服务架构体系是不是不能不使用docker和k8s？谢谢！<br>复杂性是必然的，不能随便切分服务，因为每增加一层，就增加一层复杂度<br>docker的话应该说是标配，k8s现在是docker官方的标配，使用不使用这个需要看团队的熟悉及掌握情况<br>docker是提高了资源的利用率，降低了部署的复杂性，使开发 测试 线上环境能够保持一致</p>
<p>#####Q:您好，我是来自于一家中小企业的运维和开发人员，一直很微服务很感兴趣，如果我们企业将来打算采用微服务的架构，我们将面临着哪些挑战？给不能给我们一些建议？<br>   面临着哪些挑战？<br>   1、思想的转变。首先要理解什么是微服务。<br>   2、新技术以及新框架的学习。比如spring boot、docker等。<br>   给不能给我们一些建议？<br>   1、本书的第一章讲解了传统的架构和微服务架构的区别以及演变流程，可以首先有一个概念性的了解。<br>   2、可以先让一部分人使用并且深入，然后在整体推广</p>
<p>#####Q:我想请问一下，微服务的粒度到底怎么划分，有什么经验吗<br>这个也是个设计问题，首先是业务必须熟悉，然后可以根据领域模型进行领域划分，拆分可以根据AKF扩展立方体（Scalability Cube），<br>这个立方体有三个轴线，每个轴线描述扩展性的一个维度，他们分别是产品、流程和团队：<br>X轴 —— 代表无差别的克隆服务和数据，工作可以很均匀的分散在不同的服务实例上；<br>Y轴 —— 关注应用中职责的划分，比如数据类型，交易执行类型的划分；<br>Z轴 —— 关注服务和数据的优先级划分，如分地域划分。<br>三个维度扩展的对比</p>
<p>通过这三个维度上的扩展，可以快速提高产品的扩展能力，适应不同场景下产品的快速增长。不同维度上的扩展，有着不同的优缺点：<br>1.X轴扩展<br>优点：成本最低，实施简单；<br>缺点：受指令集多少和数据集大小的约束。当单个产品或应用过大时，服务响应变慢，无法通过X轴的水平扩展提高速度；<br>场景：发展初期，业务复杂度低，需要增加系统容量。<br>2.Y轴扩展<br>优点：可以解决指令集和数据集的约束，解决代码复杂度问题，可以实现隔离故障，可以提高响应时间，可以使团队聚焦更利于团队成长；<br>缺点：成本相对较高；<br>场景：业务复杂，数据量大，代码耦合度高，团队规模大。<br>3.Z轴扩展<br>优点：能解决数据集的约束，降低故障风险，实现渐进交付，可以带来最大的扩展性。<br>缺点：成本最昂贵，且不一定能解决指令集的问题；<br>场景：用户指数级快速增长。<br>如何将理论付诸实践？</p>
<p>1.为扩展分割应用<br>X轴：从单体系统或服务，水平克隆出许多系统，通过负载均衡平均分配请求；<br>Y轴 ：面向服务分割，基于功能或者服务分割，例如电商网站可以将登陆、搜索、下单等服务进行Y轴的拆分，每一组服务再进行X轴的扩展；<br>Z轴 ：面向查找分割，基于用户、请求或者数据分割，例如可以将不同产品的SKU分到不同的搜索服务，可以将用户哈希到不同的服务等。<br>2.为扩展分割数据库<br>X轴：从单库，水平克隆为多个库上读，一个库写，通过数据库的自我复制实现，要允许一定的读写时延；<br>Y轴 ：根据不同的信息类型，分割为不同的数据库，即分库，例如产品库，用户库等；<br>Z轴 ：按照一定算法，进行分片，例如将搜索按照MapReduce的原理进行分片，把SKU的数据按照不同的哈希值进行分片存储，每个分片再进行X轴冗余。<br>3.为扩展而缓存<br>在理想情况下，处理大流量最好的方法是通过高速缓存来避免处理它。从架构层面看，我们能控制的主要有以下三个层次的缓存：<br>对象缓存：对象缓存用来存储应用的对象以供重复使用，一般在系统内部，通过使用应用缓存可以帮助数据库和应用层卸载负载。<br>应用缓存：应用缓存包括代理缓存和反向代理缓存，一个在用户端，一个在服务端，目标是提高性能或减少资源的使用量。<br>内容交付网络缓存：CDN的总原则是将内容推送到尽可能接近用户终端的地方，通过不同地区使用不同ISP的网关缓存，达到更快的响应时间和对源服务的更少请求。<br>4.为扩展而异步<br>同步改异步：同步调用，由于调用间的同步依赖关系，有可能会导致雪崩效应，出现一系列的连锁故障，进而导致整个系统出现问题，所以在进行系统设计时，要尽可能的考虑异步调用方式，邮件系统就是一个非常好的异步调用例子。<br>应用无状态：当进行AKF扩展立方体的任何一个轴上的扩展时，都要首先解决应用的状态问题，即会话的管理，可以通过避免、集中和分散的方式进行解决。</p>
<p>#####Q:您好，请教一下，在基于Spring Cloud的微服务架构中，使用docker和k8s这些容器化技术能带来哪些方面的好处？对于中小规模的微服务架构中，是否有使用docker和k8s的必要性呢？谢谢。<br>容器技术不是模仿硬件层次，而是 在Linux内核里使用cgroup和namespaces来打造轻便的、将近裸机速度的虚拟技术操作系统环境。因为不是虚拟化存储，所以容器技术不会管 底层存储或者文件系统，而是你放哪里，它操作哪里。<br>也就是说，它能更细粒度的控制linux，能够做到按需分配，我们企业级开发种经常面临的一个问题就是资源不足，而使用docker可以更加有效的利用资源。这个跟企业的规模个人感觉不是很大。</p>
<p>#####Q:您好，我想问下在您10多年的职业生涯中，您对自己最满意的项目是哪个，它给你带来了哪些收获呢？<br>其实是接触服务化之后，涉及到微服务改造的项目，说收获吧，有效的提升了自己的架构能力，开阔了视野，从一个简单的CRUD码农晋升为架构级别，面对高并发以及大数据的挑战，有了应对的心得和体会。</p>
<p>#####Q:微服务怎么实现事务管理的？<br>其实微服务的事务就是分布式事务，刚性事务和柔性事务。<br>刚性事务是指严格遵循ACID原则的事务, 例如单机环境下的数据库事务。<br>柔性事务是指遵循BASE理论的事务, 通常用在分布式环境中, 常见的实现方式有: 两阶段提交(2PC), TCC补偿型提交, 基于消息的异步确保型, 最大努力通知型.。<br>分布式事务的各种实现方式：<br>如果业务场景需要强一致性, 那么尽量避免将它们放在不同服务中, 也就是尽量使用本地事务, 避免使用强一致性的分布式事务.<br>如果业务场景能够接受最终一致性, 那么最好是使用基于消息的最终一致性的方案(异步确保型)来解决.<br>如果业务场景需要强一致性, 并且只能够进行分布式服务部署, 那么最好是使用TCC方案而不是2PC方案来解决.</p>
<p>#####Q:微服务架构和传统的SOA架构有什么区别？仅仅只是微服务系统更小吗？<br>面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样系统中的服务可以以一种统一和通用的方式进行交互。<br>都是做服务化，那么微服务与SOA的异同有哪些呢？<br>相同点<br>需要Registry，实现动态的服务注册发现机制。<br>需要考虑分布式下面的事务一致性，CAP原则下，两段式提交不能保证性能，事务补偿机制需要考虑。<br>同步调用还是异步消息传递，如何保证消息可靠性？SOA由ESB来集成所有的消息。<br>都需要统一的Gateway来汇聚、编排接口，实现统一认证机制，对外提供APP使用的RESTful接口。<br> 同样要关注如何再分布式下定位系统问题，如何做日志跟踪？就像电信领域做了十几年的信令跟踪的功能。<br>差异点<br>是持续集成、持续部署？对于CI、CD（持续集成、持续部署），这本身和敏捷、DevOps是交织在一起的，所以更倾向于软件工程的领域而不是微服务技术本身。<br>使用不同的通信协议是不是区别？微服务的标杆通信协议是RESTful，而传统的SOA一般是SOAP，不过目前来说采用轻量级的RPC框架（Dubbo、Thrift、gRPC）非常多，在Spring Cloud中也有Feign框架将标准RESTful转为代码的API这种仿RPC的行为，这些通信协议不应该是区分微服务架构和SOA的核心差别。<br> 是流行的基于容器的框架还是虚拟机为主？Docker虚拟机和物理机都是架构实现的一种方式，不是核心区别。<br>SOA和微服务的一个主要不同点就是自动化程度上的不同。大部分的SOA实现只达到服务级别的抽象，而微服务达到了对实现和运行环境的抽象级别。<br>在一个规范的微服务中，每个微服务应该被构建成胖JAR（fat JAR），其中内置了所有的依赖，然后作为一个单独的Java进程存在。</p>
<p>#####Q:您好，想请教下微服务模式下数据库的管理，多个服务之间的数据聚合怎么做才能避免数据过于分散导致查询实现困难？感觉 k8s 可以代替 spring cloud 的一些组件（比如均衡负载，配置服务，服务发现），如何才能分清它们之间的关系？<br>数据聚合<br>这个其实设计到微服务的一种设计模型，微服务的设计模式主要有以下几种：链式设计模式、聚合器设计模式、数据共享设计模式和异步消息控制模式。<br>聚合器设计模式是将请求统一由网关路由到聚合器，聚合器向下路由到指定的微服务中获取结果，并且完成聚合，如图2-5所示。首页展现、分类搜索和个人中心等通常都使用这种设计。</p>
<p>数据共享模式也是微服务设计模式的一种。应用通过网关调用多个微服务，微服务之间的数据共享通过同一个数据库，这样能够有效地减少请求次数，并且对于某些数据量小的情况非常适合，如图2-6所示。</p>
<p>也就是说，服务需要经过一定的设计处理。可以再网关部分实现数据查询的路由。</p>
<p>两个平台在核心领域都很强，并且在其他领域改进。Spring Cloud可以快速使用、对开发者友好的平台，然而Kubernetes对DevOps友好，艰难的学习曲线，但是覆盖更广泛的微服务障碍。以下是这些点的总结。<br>优点和缺点<br>两种架构处理了不同范围的MSA障碍，并且它们从根本上用了不同的方法。Spring Cloud方法是试图解决在JVM中每个MSA挑战，然而Kubernetes方法是试图让问题消失，为开发者在平台层解决。Spring Cloud在JVM中非常强大，Kubernetes管理那些JVM很强大。同样的，它就像一个自然发展，结合两种工具并且从两个项目中最好的部分受益。</p>
<p>#####Q:对于 #Jboot# 你怎么看？<br>从个人爱国的角度，我是非常支持Jboot这种开源项目的。而且它加入了很多符合中国企业级服务的东西在里边。<br>我觉得选择框架要基于两点：<br>1、开源项目更新的频率，如果更新的比较快，那么说明可维护性比较高，可以尝试使用。<br>2、使用群体，如果使用群体比较小众，那么很多坑就很难被发现，一旦在线上环境遇到，就会很难处理。还有就是如果使用的群体较小的话，遇到问题的时候解决的周期会较耗时。</p>
<p>#####Q:老师您好微服务之间通讯方式除了 RPC 还有哪些？<br>通常建议微服务之间使用RPC 的方式进行通信。但是像百度、google内部都使用brpc grpc进行通信。<br>蚂蚁金服使用的框架是SOFARPC，所以，如果公司内部能够统一，可以选择一套成型的rpc框架。</p>
<p>#####Q:您好，目前DUBBO重新启动后支持了更多语言，但是我们之前体验基于DUBBO的微服务时感觉不舒服，因为要设计出一个聚合层接收HTTP请求。对这部分内容您怎么看？之前试图增加一个BFF层，但是发现如果前端/移动端人员没有能力维护这一层，或者这一层耦合了业务的话，对后端人员是增加了工作量，最后放弃了。您这方面有什么经验么？目前微服务框架特别多，GOA等等都发了新版本，您对他们和SPRING CLOUD之间的取舍有什么意见么？最后就是现在有很多PAAS平台帮助实施微服务，甚至提供了Service mesh，您觉得这会是未来的趋势么？毕竟源生K8S还是比较有难度的。<br>DUBBO的主要功能还是在服务治理。聚合层可以参考网关，比如zuul。<br>关于BFF，一般现在都是前后端分离，前端框架可以使用angularjs vue等。<br>GOA是go语言的吧，spring cloud是java语言的，微服务是语言无关的，也就是哪个实现更好就使用哪个。我们团队服务端java人员较多，所以选择的spring cloud。<br>可以参考阿里云的实现：<br><a href="https://www.aliyun.com/product/edas?utm_medium=text&amp;utm_source=baidu&amp;utm_campaign=zhongjianjian&amp;utm_content=se_1000125613" target="_blank" rel="noopener">https://www.aliyun.com/product/edas?utm_medium=text&amp;utm_source=baidu&amp;utm_campaign=zhongjianjian&amp;utm_content=se_1000125613</a></p>
<p>#####Q:老师 您好 我 对这两个问题比较感兴趣,您能简单说下吗 目前公司正在使用微服务,但是怎么控制质量,这点大家都没有什么好建议, 监听工具也集成了一个 zipkin 但是没有使用起来6.微服务如何做质量管理？7.常用的 APM 监控工具包括哪些？<br>微服务如何做质量管理？<br>其实可以做一些静态代码检查，比如使用checkstyle等。详细的书中有提到。<br>常用的 APM 监控工具包括哪些？<br>cat pinpoint zipkin也算一种，这些都是无侵入式的，基本不对现有工程做任何影响。详细的书中也有提到</p>
<p>#####Q:我想问下，对于一个工作五年的java工程师，也做过无数的项目，简单的分布式项目也搭建过，但我一直想向架构方面靠拢，如何才能在这条路上入门呢？根据您的架构经验来看，平常有什么是值得注意的，技术转型最重要的是什么呢？<br>首先5年已经算是高级工程师了，但是无数的项目不太理解是什么意思，如果项目多，说明参与的项目规模比较小，如果想做架构的话，需要多关注底层的实现原理，多了解比如分布式的实现，以及如何应对高并发等。</p>
<p>#####Q:微服务现在的概念比较火，大家都使用什么框架来构建微服务？它跟软件工程的关系是怎么样的？<br>现在比较流行的是spring cloud体系，与docker结合，利用spring boot的简化开发来整体构建，关于完整的流程及示例可以参考我书中的内容。<br>我们知道，微服务就是把大的工程进行切分，能够独立测试和部署，总的来说就是分而治之的思想。</p>
<p>#####Q:实施微服务架构之后，系统就多了，测试就复杂了，尤其是异常场景的测试，这一块有什么好的解决方案<br>这个对测试的要求很高，而且部署也相对复杂，如果项目小的话可以少拆分。大项目需要开发团队和测试团队紧密配合，运用最为广泛的是基本路径测试法。<br>基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。<br>设计出的测试用例要保证在测试中程序的语句覆盖100%，条件覆盖100%。</p>
<p>#####Q:您好，想请问一下关于微服务的问题定位。有什么经验吗？设计微服务，考虑粒度，这些有参考资料可以了解一下吗？<br>粒度业务不同拆分的服务就不同，通常可以根据系统访问的热度来进行拆分。</p>
<p>#####Q:你们线上使用的参数配置服务是？你们的微服务中怎么做服务灰度的？关于熔断、限流简单引入Hystrix　然后仿照网上的写法就可以了吗？你们的产品是什么类型，怎么拆分服务模块的？<br>配置服务apollo挺好的，基于sprng cloud config的封装。<br>灰度这个可以参考k8s的做法，做滚动升级。<br>熔断可以根据自身业务的特点进行设计，配置</p>
<p>#####Q:你好，微服务中，接口入参和返回类型，通常我们都是定义成了一个bean，那么调用方需要调用的时候，也需要这个bean，如何设计才能避免类的重复声明？提取一个api模块吗？<br>单独提出一个两个都依赖的工程也可以，一般使用dubbo做分布式都是这样实现</p>
<p>#####Q:你好，问一个和微服务无关的话题，希望能得到你的回答。假设现在我们的业务是面向3端的，app.h5.pc，你们会针对同一个接口写三套实现还是公用一套独立部署？如果，页面显示的字段值80%相同，20%不同？又如何弄<br>这个典型的一个网关的应用场景啊<br>网关可以看作一个各种微服务的入口。通常一个系统可以有一个或者多个网关。<br>可以给不同的端设置不同的访问网关，这样当某个端出现问题时，不会导致整个系统瘫痪。网页端使用Web网关，手机端使用手机网关，但可以使用同一套服务。在服务中可以以报文的方式对各个端进行标识。</p>
<p>#####Q:你好！据我了解，Spring Boot(包含Cloud组件) + Docker + Jenkins 是一套非常不错解决方案，您觉得这套方案怎么样？另外，说到Docker就不得不说Swarm和K8s，您觉得容器群达到什么样的规模，您会考虑K8s？我个人觉得，如果只是七八台机器，二十多个容器，应该是没有必要上K8s的，Swarm完全没有问题。<br>对，Spring Boot(包含Cloud组件) + Docker + Jenkins 是一套非常不错解决方案<br>如果集群规模比较小，使用swarm比较灵活</p>
<p>#####Q:请问下 你们配置中心用哪个解决方案<br>apollo配置中心</p>
<p>#####Q:老师能不能谈谈你在微服务方面都掉进过哪些坑？又是怎么爬出来的？我想这些更有借鉴意义~~ 只是需要牺牲你一下，自爆家丑了~~<br>这么说吧，一个微服务的完整流程想弄清楚就需要一段时间，然后还涉及到团队的技术推广，团队成员本身技术参差不齐，我感觉沟通的问题甚至大于采坑</p>
<p>#####Q:什么才是微服务，公司使用springboot把不同的模块做成一个服务，多个服务之间用springcloud调用，当服务很多的时候，产品出现问题，排查的时候比较繁琐，有什么好的方式可以监控这些问题，能够让我们更好的快速的定位产品出现问题的位置，快速解决<br>这是一个典型的APM监控的问题，书中有一章专门介绍</p>
<p>#####Q:您好，微服务这块，拆分的点依赖什么？  拆分后事物是怎么保证的，<br>AKF拆分原则<br>数据一致性分为以下几种情况：<br>          强一致性<br>当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据CAP理论，这种实现需要牺牲可用性。<br>          弱一致性<br>系统并不保证后续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体地承诺多久之后可以读到。<br>          最终一致性<br>弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟、系统负载和复制副本的个数影响。DNS是一个典型的最终一致性系统。</p>
<p>#####Q:在一些传统的应用场景（PV、UV较低），适合用oauth鉴定场景吗？<br>这个是安全那一块啊，跟pv uv的量关系不大吧</p>
<p>#####Q:我把一个数据库拆成20多个微服务 . 查用户数据文章资源的时候,  用户信息是一个微服务, 文章资源又是一个微服务. 拆的太细了, 调用接口都不方便<br>数据量不大的话不建议拆分，而且感觉拆的太细了，另外，如果同库的话为什么要拆分？</p>
<p>#####Q:微服务如何方便简单的调试比如spring cloud，服务之间互相有调用就需要在本地都起来才可以开始调试(需要eueka server，zull，需要调试的service，启动完这些才可以开始调试)， 目前可以想到的就是在公司内部搭建一套开发环境的微服务。但是这样如果有多个人连接一套开发环境很容易就自动变成集群了。<br>如果用spring cloud技术栈可以以小组为单位，构建一套开发环境，或者如果资源足够的话，可以使用docker为每个人单独搭建自己的开发环境</p>
<p>#####Q:我像请教下，给予微服务  分布式 springcloud  分布式事务方面有没有什么好一点的 解决方案。<br>这个之前回答了一下，可以参考一下。<br>其实微服务的事务就是分布式事务，刚性事务和柔性事务。<br>刚性事务是指严格遵循ACID原则的事务, 例如单机环境下的数据库事务。<br>柔性事务是指遵循BASE理论的事务, 通常用在分布式环境中, 常见的实现方式有: 两阶段提交(2PC), TCC补偿型提交, 基于消息的异步确保型, 最大努力通知型.。<br>分布式事务的各种实现方式：<br>如果业务场景需要强一致性, 那么尽量避免将它们放在不同服务中, 也就是尽量使用本地事务, 避免使用强一致性的分布式事务.<br>如果业务场景能够接受最终一致性, 那么最好是使用基于消息的最终一致性的方案(异步确保型)来解决.<br>如果业务场景需要强一致性, 并且只能够进行分布式服务部署, 那么最好是使用TCC方案而不是2PC方案来解决.</p>
<p>#####Q:项目微服务化后带来了一系列的问题。比如事务，请问作者在日常项目中所采用的解决方案是什么<br>我们一般是用<br>如果业务场景能够接受最终一致性, 那么最好是使用基于消息的最终一致性的方案(异步确保型)来解决.</p>
<p>#####Q:老师，您好。目前公司已微服务的理念用SpringCloud技术栈在开发，但是部署不能放在公网上，项目没有docker化，对于这种无法使用公网资源的情况，请问老师有没有好的解决思路或者是实践方法？<br>你们是互联网类的项目？这种一般都是暴露一部分服务给外部调用，可以选择nginx做反向代理，并且对于服务做高可用。<br>docker可以在内部项目中使用，如果这方面没经验，直接使用虚拟机也是可以的。</p>
<p>#####Q:微服务的运维和监控，是不是更麻烦了呢<br>现在一般都使用APM工具对总体做监控，比如pinpoint</p>
<p>#####Q:微服务之间,A服务要依赖B，C服务，怎么办，请求A服务时，怎么合并B，C服务返回的结果。注意什么，有哪些方式？谢谢〜〜<br>这个就跟正常的程序逻辑差不多，只是因为分布式的原因，需要加上熔断处理等，就是需要防止因为B、C服务不可用导致的雪崩效应。<br>这一部分在书中有讲到。</p>
<p>#####Q: 您好，我想咨询一下微服务业务层如何进行分层？业务系统如何定级，标准为什么？<br>设计原则之分层架构</p>
<p>同一公司使用统一应用分层，以减少开发维护学习成本。应用分层看起来很简单，但每个程序员都有自己的一套方法，哪怕是初学者，所以想实施起来并非那么容易。<br>最早接触的分层架构应该是我们最熟悉的MVC（Model-View-Controller）架构，其将应用分成了模型、视图和控制层，可以说引导了绝大多数开发者。而现在的应用（包括框架）中非常多架构设计都使用此模式。之后又演化出了MVP（Model-View-Presenter）和MVVM（Model-View-ViewModel）。这些可以说都是随着技术的不断发展，为了应对不同场景所演化出来的模型。而微服务的每个架构都可以再细分成领域模型，下面看一下经典的领域模型架构。<br>它包括了Domain、Service和Repositories。核心实体（Entity）和值对象（Value Object）应该在Domain层，定义的领域服务（Domain Service）在Service层，而针对实体和值对象的存储和查询逻辑都应该在Repositories层。值得注意的是，不要把Entity的属性和行为分离到Domain和Service两层中去实现，即所谓的贫血模型，事实证明这样的实现方式会造成很大的维护问题。基于这种设计，工程的结构可以构造为：</p>
<ul>
<li>MicroService-Sample/src/<br>  domain<br>  gateways<br>  interface<br>  repositories<br>  services</li>
</ul>
<p>当然，在微服务的架构中，每个微服务不必严格遵照这样的规定，切忌死搬硬套，最重要的是理解业务。在不同的业务场合，架构的设计可以适当地调整，毕竟适合的架构一定要具有灵活性。<br>分层的原则如下<br>          文件夹分层法<br>应用分层采用文件夹方式的优点是可大可小、简单易用、统一规范，可以包括5个项目，也可以包括50个项目，以满足所有业务应用的多种不同场景。<br>          调用规约<br>在开发过程中，需要遵循分层架构的约束，禁止跨层次的调用。<br>          下层为上层服务<br>以用户为中心，以目标为导向。上层（业务逻辑层）需要什么，下层（数据访问层）就提供什么，而不是下层（数据访问层）有什么，就向上层（业务逻辑层）提供什么。<br>          实体层规约<br>Entity是数据表对象，不是数据访问层对象；DTO是网络传输对象，不是表现层对象；BO是内存计算逻辑对象，不是业务逻辑层对象，不是只能给业务逻辑层使用。如果仅限定在本层访问，则导致单个应用内大量没有价值的对象转换。以用户为中心来设计实体类，可以减少无价值重复对象和无用转换。<br>          U型访问<br>下行时表现层是Input，业务逻辑层是Process，数据访问层是Output。上行时数据访问层是Input，业务逻辑层是Process，表现层是Output。</p>
<p>#####Q:我翻阅了好几本国内外各大高校广泛采用的软件工程、计算机专业的教材，都没有提到微服务这个概念。不过，书上倒是提到了一个相似的概念，那就是面向服务的架构（SOA）。所以说国内总是喜欢炒作一些概念，就好像不玩点新的就活不下去似的。微服务并不是技术标准，没有哪个标准化组织将其列为标准。我个人不推荐使用这个概念，因为不同的人对这个概念的理解是不一样的。我倒是提倡使用SOA，因为SOA是标准，Open Group就对其做了定义。并且SOA还有对应的建模语言，SoaML。<br>面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样系统中的服务可以以一种统一和通用的方式进行交互。<br>都是做服务化，那么微服务与SOA的异同有哪些呢？<br>相同点<br>          需要Registry，实现动态的服务注册发现机制。<br>          需要考虑分布式下面的事务一致性，CAP原则下，两段式提交不能保证性能，事务补偿机制需要考虑。<br>          同步调用还是异步消息传递，如何保证消息可靠性？SOA由ESB来集成所有的消息。<br>          都需要统一的Gateway来汇聚、编排接口，实现统一认证机制，对外提供APP使用的RESTful接口。<br>          同样要关注如何再分布式下定位系统问题，如何做日志跟踪？就像电信领域做了十几年的信令跟踪的功能。<br>差异点<br>          是持续集成、持续部署？对于CI、CD（持续集成、持续部署），这本身和敏捷、DevOps是交织在一起的，所以更倾向于软件工程的领域而不是微服务技术本身。<br>          使用不同的通信协议是不是区别？微服务的标杆通信协议是RESTful，而传统的SOA一般是SOAP，不过目前来说采用轻量级的RPC框架（Dubbo、Thrift、gRPC）非常多，在Spring Cloud中也有Feign框架将标准RESTful转为代码的API这种仿RPC的行为，这些通信协议不应该是区分微服务架构和SOA的核心差别。<br>          是流行的基于容器的框架还是虚拟机为主？Docker虚拟机和物理机都是架构实现的一种方式，不是核心区别。<br>SOA和微服务的一个主要不同点就是自动化程度上的不同。大部分的SOA实现只达到服务级别的抽象，而微服务达到了对实现和运行环境的抽象级别。<br>在一个规范的微服务中，每个微服务应该被构建成胖JAR（fat JAR），其中内置了所有的依赖，然后作为一个单独的Java进程存在。</p>
<p>#####Q:您好，对于企业软件：ERP、CRM、PDM、WMS、MES、HRMS、OA，各自都是独立的系统，适合改造成微服务吗？，适合，其实这是一个典型的微服务应用的场景，这些独立系统是市场上买回来的成熟产品，只是进行部分二次开发能实现微服务吗？国内有没有大企业把SAP、OracleEBS这样的ERP产品使用微服务改造？谢谢<br>如果不是自己开发的，购买的第三方的可能需要对原有系统进行改造，这种其实成本并不低。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://alexrencn.github.io/alex.github.io/2018/09/12/2018-08-22-Oracle执行计划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Ren">
      <meta itemprop="description" content="JAVA之路">
      <meta itemprop="image" content="/alex.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/alex.github.io/2018/09/12/2018-08-22-Oracle执行计划/" itemprop="url">
                  Oracle执行计划
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-12 13:54:21" itemprop="dateCreated datePublished" datetime="2018-09-12T13:54:21+08:00">2018-09-12</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/alex.github.io/2018/09/12/2018-08-22-Oracle执行计划/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/alex.github.io/2018/09/12/2018-08-22-Oracle执行计划/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/alex.github.io/2018/09/12/2018-08-22-Oracle执行计划/" class="leancloud_visitors" data-flag-title="Oracle执行计划">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<blockquote>
<p>如何针对Oracle数据库的看到的执行计划分析sql并想办法优化</p>
</blockquote>
<h4 id="查询Oracle语句的执行计划"><a href="#查询Oracle语句的执行计划" class="headerlink" title="查询Oracle语句的执行计划"></a>查询Oracle语句的执行计划</h4><ul>
<li>在工具→首选项→窗口类型→计划窗口选择需要查看的列</li>
<li>在窗口列表→右键→新建→解释计划窗口</li>
<li>输入需要分析的SQL，执行查询</li>
</ul>
<h4 id="分析Oracle语句的执行计划"><a href="#分析Oracle语句的执行计划" class="headerlink" title="分析Oracle语句的执行计划"></a>分析Oracle语句的执行计划</h4><h5 id="什么样的执行计划是优秀的"><a href="#什么样的执行计划是优秀的" class="headerlink" title="什么样的执行计划是优秀的"></a>什么样的执行计划是优秀的</h5><ul>
<li>对于串行执行，关注的是开销</li>
<li>对于并行执行，关注的是性能</li>
</ul>
<ol>
<li>开销指使用的<strong>工作单元</strong>或<strong>资源的数量</strong> <ol>
<li>工作单元：CPU、内存、IO</li>
<li>资源的数量：对执行操作需要使用的CPU、内存、IO数量预估</li>
</ol>
</li>
<li>性能指对查询的最快响应时间，不关心占用资源</li>
</ol>
<h5 id="执行计划是否正确"><a href="#执行计划是否正确" class="headerlink" title="执行计划是否正确"></a>执行计划是否正确</h5><h6 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h6><p>基数用来返回预估的行数，计算方式为行的总数/不同值的总数<br><br>基数影响访问方法、联接类型、联接顺序等<br></p>
<ol>
<li>解决错误<ul>
<li>统计信息陈旧缺少  DBMS_STATS</li>
<li>数据偏差  创建柱状图</li>
<li>一个表有多个单列谓词  使用DBMS_STATS.CREATE_EXTENDED_STATS创建一个列组</li>
<li>一个联结中使用多个列  使用DBMS_STATS.CREATE_EXTENDED_STATS创建一个列组</li>
<li>包含函数的列  使用DBMS_STATS.CREATE_EXTENDED_STATS创建有关包含函数列的统计信息</li>
<li>复杂表达式，包含多个表的列    采用4级或更高的动态抽样级别</li>
</ul>
</li>
</ol>
<h6 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h6><ul>
<li><strong>完整表扫描</strong>，读取全部数据行，过滤不符合where字句谓词的行，用于索引，DOP集等</li>
<li><strong>按RowID访问</strong>，包含数据行所在的数据文件、数据块、数据块位置的信息，之后where条件里带rowid时使用</li>
<li><strong>索引唯一扫描</strong>，语句中包含UNIQUE索引或者PRIMARY KEY主键约束条件时使用，确定访问数据只有一行</li>
<li><strong>索引范围扫描</strong>，访问相邻索引项，可以返回多个rowid值，与等式一起用于非唯一索引，或与范围谓词一起用于唯一索引（&lt;、&gt;、between等）</li>
<li><strong>索引跳过扫描</strong>，如果前导列中只有很少的不同值，非前导列中有很多不同值，跳过前导列，使用其余有用的部分</li>
<li><strong>完整索引扫描</strong>，处理索引所有的页块，当所有需要的列都在索引中而且order by字句和索引结构匹配，或者排序合并链接完成可以使用</li>
<li><strong>快速完整索引扫描</strong>，扫描索引中的所有块，在所有需要的列都在索引中时提到FTS，使用多块IO并行允许</li>
<li><strong>索引链接</strong>，散列链接多个索引，这些索引一起包含查询中所有表列，不会消除排序操作</li>
<li><strong>位图索引</strong>，使用键值位图和映射函数，映射函数可以将每个比特转换为一个rowid，可以有效合并where字句中多个条件的索引<blockquote>
<p>解决错误，检查基数，联结顺序</p>
</blockquote>
</li>
</ul>
<ol>
<li>使用表扫描<ul>
<li>DOP针对表，而不是索引或者MBRC</li>
</ul>
</li>
<li>采用错误的索引<ul>
<li>统计信息陈旧、缺少</li>
<li>采用了匹配最多列的索引</li>
<li>完整索引访问方式的开销比索引查找后根表访问方式的开销低</li>
</ul>
</li>
</ol>
<h6 id="链接类型"><a href="#链接类型" class="headerlink" title="链接类型"></a>链接类型</h6><ul>
<li><strong>嵌套循环链接</strong>：外部表的每一行，访问内部表的所有行，在链接小型内部表或者使用索引查找时有用</li>
<li><strong>散列链接</strong>：对连个较小的表执行扫描，使用结果行根据内存中的链接创建散列表，对结果航的联结列执行散列操作，用于较大的表和if、equality谓词时有用</li>
<li><strong>排序合并链接</strong>：包括两步骤，1排序联结操作，基于联结键对两个输入都进行排序，2.合并链接操作，将排序的列表结合在一起，在表连接条件是不相等条件时非常有用</li>
<li><strong>笛卡尔链接</strong>：两个数据源，其中一个数据源的每一行和另一个数据源每一行都进行链接，生成笛卡尔乘积的数据集，在两个数据集间没有任何条件是是唯一选择</li>
<li><strong>外连接</strong>：返回所有满足联结条件的行，并从没有（+）的表中返回所有这样的行，在另一个表中没有满足联结条件的行</li>
</ul>
<blockquote>
<p>建议</p>
</blockquote>
<ul>
<li>从可消除最多行数的表进行操作</li>
<li>将受可用访问方法的很大影响<blockquote>
<p>基本规则</p>
</blockquote>
</li>
<li>总先执行生成最多生成一行的链接</li>
<li>使用外联结时，在谓词中，含有此外连接运算符的表必须在其他表之后</li>
<li>如果不能执行试图合并，在链接视图外部的表之前链接视图内部的表</li>
</ul>
<h6 id="分区修剪"><a href="#分区修剪" class="headerlink" title="分区修剪"></a>分区修剪</h6><p>根据数据表的数据量是否需要分区，需要考虑在分区后的查询中能否过滤大部分的数据行，以及范围查询会不会命中多个分区</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/alex.github.io/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/alex.github.io/">1</a><span class="page-number current">2</span><a class="page-number" href="/alex.github.io/page/3/">3</a><a class="extend next" rel="next" href="/alex.github.io/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Alex Ren</p>
              <p class="site-description motion-element" itemprop="description">JAVA之路</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/alex.github.io/archives/">
                
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/AlexRenCN" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Ren</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/alex.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/alex.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/alex.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/alex.github.io/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/alex.github.io/js/src/motion.js?v=6.4.1"></script>



  
  

  

  


  <script type="text/javascript" src="/alex.github.io/js/src/bootstrap.js?v=6.4.1"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'VooWzCTKIYsM5LgzWVUF6cuL-gzGzoHsz',
        appKey: 'mjrOD1ERYDgolUpulB6JU9pQ',
        placeholder: 'Just go go',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: true
    });
  </script>



  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
